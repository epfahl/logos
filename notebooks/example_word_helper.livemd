# Word game helper

## Background

## Words rule

## Three kinds of letters

## The code

```elixir
defmodule Parse do
  alias Logos.Variable, as: V

  def parse_excluded("~" <> ls), do: String.graphemes(ls)

  def parse_input(input) do
    acc_init = %{var_count: 0, tokens: [], not_here: %{}, included: []}
    input |> List.foldr(acc_init, &reducer/2)
  end

  def reducer("*", acc) do
    v = V.new("v#{acc.var_count}")

    %{
      acc
      | tokens: [v | acc.tokens],
        var_count: acc.var_count + 1
    }
  end

  def reducer("~" <> ls, acc) do
    not_here = String.graphemes(ls)
    v = V.new("v#{acc.var_count}")

    %{
      acc
      | tokens: [v | acc.tokens],
        var_count: acc.var_count + 1,
        not_here: Map.put(acc.not_here, v, not_here),
        included: not_here ++ acc.included
    }
  end

  def reducer(l, acc) do
    %{acc | tokens: [l | acc.tokens]}
  end
end

defmodule Help do
  use Logos
  # alias Logos.Variable, as: V

  @word_list File.stream!("notebooks/five_letter_words.txt")
             |> Stream.map(&String.trim/1)
             |> Enum.to_list()

  def all_words(), do: @word_list

  @doc """
  Rule that succeeds if `w` is a word in the word list.
  """
  defrule word(w) do
    member(w, @word_list |> Enum.map(&String.graphemes/1))
  end

  @doc """
  Rule that fails if `x` and `y` successfully unify.
  """
  defrule not_equal(x, y) do
    choice do
      equal(x, y) -> failure()
      success() -> success()
    end
  end

  @doc """
  Rule that fails if `x` is a member of list `l`.
  """
  defrule not_member(x, l) do
    choice do
      member(x, l) -> failure()
      success() -> success()
    end
  end

  def suggest(input, excluded \\ "") do
    excl = Parse.parse_excluded(excluded)

    %{
      tokens: tokens,
      not_here: not_here,
      included: included
    } = Parse.parse_input(input)

    # This is where Logos is embedded.
    ask [w] do
      [word(w), equal(w, tokens)] ++
        for(l <- included, do: member(l, w)) ++
        for({v, ls} <- not_here, do: not_member(v, ls)) ++
        for(l <- excl, do: not_member(l, w))
    end
    |> Stream.uniq()
    |> Stream.map(&Enum.join(&1, ""))
  end
end
```

```elixir

```
